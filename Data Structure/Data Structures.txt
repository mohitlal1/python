Data Structures:

Stacks, Lists and Queue:

Stack: Stack is a data structure that follows the LIFO (Last In First Out) principle. This include 2 operations: Push and Pop.

    # Code to demonstrate Implementation of   
    # stack using list   
    x = ["Python", "C", "Android"]   
    x.push("Java")   
    x.push("C++")   
    print(x)   
    print(x.pop())   
    print(x)   
    print(x.pop())   
    print(x)   
	
Queue: A Queue follows the First-in-First-Out (FIFO) principle. It is opened from both the ends hence we can easily add elements to the back and can remove elements from the front. This include 2 operations: enqueue and dequeue

    import queue   
    # Queue is created as an object 'L'  
    L = queue.Queue(maxsize=10)   
      
    # Data is inserted in 'L' at the end using put()   
    L.put(9)   
    L.put(6)   
    L.put(7)   
    L.put(4)   
    # get() takes data from   
    # from the head    
    # of the Queue   
    print(L.get())   
    print(L.get())   
    print(L.get())   
    print(L.get())   

9
6
7
4

Comprehensions: It is a short way to construct new sequences (such as lists, set, dictionary etc.) using sequences that are already defined. Python supports 4 different type of comprehensions:
				1. List Comprehensions: List comprehensions provide ways to create new lists.
					
					Syntax of List Comprehension
						[expression for item in list]
						
				2. Dictionary Comprehensions: We can also create a dictionary using dictionary comprehensions. The basic structure of a dictionary comprehension looks like below.
					output_dict = {key:value for (key, value) in iterable if (key, value satisfy this condition)}
 
				3.Set comprehensions: Set comprehensions are pretty similar to list comprehensions. The only difference between them is that set comprehensions use curly brackets { }.
				
				4.Generator Comprehensions: Generator Comprehensions are very similar to list comprehensions. One difference between them is that generator comprehensions use circular brackets whereas list comprehensions use square brackets. The major difference between them is that generators don’t allocate memory for the whole list. Instead, they generate each value one by one which is why they are memory efficient. 
				
Nested Comprehensions:  Nested List Comprehensions are nothing but a list comprehension within another list comprehension which is quite similar to nested for loops.

						
# Nested list comprehension 
matrix = [[j for j in range(5)] for i in range(5)] 
  
print(matrix) 
Output:

[[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]

Sequences unpacking: Python allows unpacking of any sequence(iterable) into variables using a simple assignment operation. Unpacking can be done by assigning sequence(iterable) to comma separated variables .
						

#unpacking P into variable x and y
P=(100,200)
x,y=P
print(x)
print(y)

Output:

100
200

 Unpacking Arbitrary Number of variables: Python * expression can be used to assign arbitrary number of elements to single variable. Arbitrary number of variables will be stored in the form of list.
 language=("hello","namaste","Bonjour","Hola","Konnichiwa")
#assign first elements to english and remaining to other
english,*other=language
print("english ={}, other={}".format(english,other))

english =hello, other=['namaste', 'Bonjour', 'Hola', 'Konnichiwa']

Unpacking selective elements:

Throwaway variable _(underscore) can be used to select and discard elements during sequence unpack. _ acts as temporary variable for sequence unpack.

language=("hello","namaste","Bonjour","Hola","Konnichiwa")

#assign value to english hindi japanese discarding remaining
english,hindi,_,_,japanese=language
print("english={}, hindi={}, japanese={}".format(english,hindi,japanese))

#assign value to english and hindi
english,hindi,*_=language
print("english={}, hindi={}".format(english,hindi))

Output: english=hello, hindi=namaste, japanese=Konnichiwa
english=hello, hindi=namaste

Unpacking Multiple sequences: 

#unpacking multiple dictionaries into single
x={1:"one",2:"two"}
y={3:"three",4:"four"}
z={5:"five",6:"six",7:"seven"}

a={**x,**y,**z,8:"eight",9:"nine"}
print(a)

Output: {1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'}

x=[0,1,2,3]
y=[4,5,6,7,8,9]
#unpcking multiple list to one
z=[*x,*y]
print(z)

Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

x={1,2,3,4}
y={9,8,7}
#unpacking multiple sets to one
z={*x,*y}
print(z)

Output: {1, 2, 3, 4, 7, 8, 9}

Passing Unpacked sequence as function parameters:
 

def func(a,b,c,d):
  print("a={},  b={},  c={},  d={}".format(a,b,c,d))

#passing unpacked variable to function
x=(1,2,3,4)
func(*x)

y=[11,12,13,14]
func(*y)

z="ABCD"
func(*z)

Output:

a=1,  b=2,  c=3,  d=4
a=11,  b=12,  c=13,  d=14
a=A,  b=B,  c=C,  d=D

** expression can be used to unpack dictionary elements and pass it as keyword arguments to function.

def func(a,b,c,d):
  print("a={},  b={},  c={},  d={}".format(a,b,c,d))

#passing unpacked dictionary to function
x={'a':1,'b':2,'c':3,'d':4}
func(**x)

y={'a':"A",'b':"B",'c':"C",'d':"D"}
func(**y)


Looping Techniques in Python: 
1. Using Enumerate: Enumerate() is used to loop through the containers printing the index number along with the value present in that particular index.
	Code:	
		for key, value in enumerate(['The', 'Big', 'Bang', 'Theory']): 
		print(key, value) 
		
	Output:
		0 The
		1 Big
		2 Bang
		3 Theory

	Code: 
		for key, value in enumerate(['The', 'world', 'is', 'round', 'not', 'flat']): 
		print(value, end=' ') 
	
	Output:
		The world is round not flat
		
2. Using zip: Zip() is used to combine 2 similar containers(list-list or dict-dict) printing the values sequentially. The loop exists only till the smaller container ends.
	Code:		
		# initializing list 
		questions = ['name', 'colour', 'shape'] 
		answers = ['apple', 'red', 'a circle'] 
  
		# using zip() to combine two containers and print values 
		for question, answer in zip(questions, answers): 
			print('What is your {0}?  I am {1}.'.format(question, answer)) 
			
		Output:
			What is your name?  I am apple.
			What is your color?  I am red.
			What is your shape?  I am a circle.
			
3. Using iteritem: iteritems() is used to loop through the dictionary printing the dictionary key-value pair sequentially.		
	Code:
		d = { "Mount" : "Everest", "Mount" : "Annapurna" } 
  
		# using iteritems to print the dictionary key-value pair 
		print ("The key value pair using iteritems is : ") 
		for i,j in d.iteritems(): 
			print i,j 
			
	Output:
		The key value pair using iteritems is : 
		Mount Everest
		Mount Annapurna
		
4. Using items(): items() performs the similar task on dictionary as iteritems() but have certain disadvantages when compared with iteritems().
				  It is very time-consuming. Calling it on large dictionaries consumes quite a lot of time.
			      It takes a lot of memory. Sometimes takes double the memory when called on a dictionary.		
				  
	Code:
		d = { "Mount" : "Everest", "Mount" : "Annapurna" } 	
		
		# using items to print the dictionary key-value pair 
		print ("The key value pair using items is : ") 
		for i,j in d.items(): 
			print i,j 
			
	Output: 
		The key value pair using items is : 
		Mount Everest
		Mount Annapurna
		
5. Using sorted():  sorted() is used to print the container in sorted order. It doesn’t sort the container but just prints the container in sorted order for 1 instance. The use of set() can be combined to remove duplicate occurrences.
	Code: 
		lis = [ 1 , 3, 5, 6, 2, 1, 3 ] 
  
	# using sorted() to print the list in sorted order 
	print ("The list in sorted order is : ") 
	for i in sorted(lis) : 
		print (i,end=" ") 
      
	Output: The list in sorted order is : 
			1 1 2 3 3 5 6 
      
	Code:
	# using sorted() and set() to print the list in sorted order use of set() removes duplicates. 
	print ("The list in sorted order (without duplicates) is : ") 
	for i in sorted(set(lis)) : 
		print (i,end=" ") 

	Output: The list in sorted order (without duplicates) is : 
			1 2 3 5 6 

6. Using reversed(): reversed() is used to print the values of the container in the reversed order. It does not reflect any changes to the original list
	Code: 
		lis = [ 1 , 3, 5, 6, 2, 1, 3 ] 
  
		# using revered() to print the list in reversed order 
		print ("The list in reversed order is : ") 
		for i in reversed(lis) : 
			print (i,end=" ") 
			
	Output: The list in reversed order is : 
			3 1 2 6 5 3 1 			
			
	Code: 
		for i in reversed(range(1, 10, 3)): 
			print (i) 
			
	Output:
		7
		4
		1
			